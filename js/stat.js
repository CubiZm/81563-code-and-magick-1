'use strict';

// глобальному объекту window присваиваем новое свойство — функцию
// передаём в функцию три параметра:
// объект канваса, массив имён, массив времени
window.renderStatistics = function (ctx, names, times) {

  // Создаём объект гистограммы с свойствами
  var gistogram = {
    WIDTH: 40, // Ширина колонки (задана в ТЗ)
    HEIGHT: 150, // Высота гистограммы (задана в ТЗ)
    AXIS_X: 150, // Полодение гистограммы на оси Х
    AXIS_Y: 240, // Положение Гистограммы на оси У
    INDENT_Y: 15, // Отступ по оси У
    INDENT_X: 90, // Отступ по оси Х. По заданию 50, но мы учитываем ещё и ширину колонки, так как шаг начинается с крайнего левого угла СТОБЛЦА, а не с его конца. В итоге ширина стобца 40 + 50 из задания и дадут нам 90
    PLAYER_COLOR: 'rgba(255, 0, 0, 1)', // цвет колонки у игрока
    TEXT_COLOR: 'rgba(0, 0, 0, 1)', // цвет текста
    MAX: -1, // максимальное значение рейтинга до изменений
  };


  // Тень
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // создаём чёрную заливку с прозрачностью 0.7
  ctx.fillRect(110, 20, 420, 270); // Рисуем прямоугольник с положением на оси Х 110, У 20.
  // Ширина прямоугольника 420пх, выоста 270пх

  // Облачко
  ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // создаём белую заливку с прозрачностью 1
  ctx.strokeRect(100, 10, 420, 270); // Рисуем обводку прямоугольника с положением на оси Х 100, У 10.
  // Ширина прямоугольника 420пх, выоста 270пх
  ctx.fillRect(100, 10, 420, 270); // // Рисуем белый прямоугольник с положением на оси Х 100, У 10.
  // Ширина прямоугольника 420пх, выоста 270пх

  ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // создаём чёрную заливку с прозрачностью 1
  ctx.font = '16px PT Mono'; // задаём размер шрифта и шрифт

  ctx.fillText('Ура, вы победили!', 120, 40); // выводим текст с положением по оси Х 120 и У 40
  ctx.fillText('Список результатов:', 120, 60); // выводим текст с положением по оси Х 120 и У 60

  gistogram.MAX = Math.max.apply(null, times); // находим максимальное число в массиве и переопределяем переменную
  // Используем для этого функцию Math.max и вызываем её с помощью метода apply
  // в apply передаём первым параметром значение this (у нас оно будет null), а вторым — перебираемый нами массив

  var step = gistogram.HEIGHT / gistogram.MAX; // Грубо говоря, находим 1% нашей гистограммы
  // получим в итоге чо то типа px / second

  // Создаём функцию которая будет генерировать разные оттенки синего цвета
  var getRandomBlueColor = function () {
    return 'rgba(0, 76, 255, ' + (Math.random() * 0.9 + 0.1) + ')';
    // функция возвращает строку в которой мы передаём rgba параметр синего цвета. С помощью Math.random мы как раз таки генерируем различную насыщенность синего
    // чтобы избежать значение альфа-канала больше 1 и меньше 0, то мы умножаем получившуюся цифру на 0.9 и прибавляем к ней 0.1.
    // Таким образом мы всегда получим 0 за счёт прибавления 0.1 (0 + 0.1) и не получим больше 1, так как умножаем на 0.9 (1 * 0.9 = 0.9). Math.random ограничен от 0 до 1 (не включая 1).
  };

  // Рисуем наши гистограммы
  var getStatsBar = function (time, name, j) { // передаём в функцию время игрока, имя игрока и его индекс
    ctx.fillStyle = name === 'Вы' ? gistogram.PLAYER_COLOR : getRandomBlueColor(); // задаём цвет для нашей гистограмы. Он будет зависеть от имени игрока. Если это игрок «Вы», то столбец будет красного цвета, если нет, то вызывается функция, которая будет генерировать случайный синий оттенок столбца
    ctx.fillRect(gistogram.AXIS_X + (gistogram.INDENT_X * j), gistogram.AXIS_Y, gistogram.WIDTH, (time * -step)); // отрисовываем наш столбец. Первый параметр — положение на оси X, который мы складываем с расстоянием между столбцами по оси Х умноженное на индекс элемента.
    // параметр У статичен в данном случае
    // Ширина столбца так же всегда статична
    // высота рассчитывается по пропорции. Я хз как её изобразить, но в общем мы умножаем время (секунды) на наш step (который у нас как раз является условным «1%» высоты. В итоге такого умножения наши секунды сокращаются и мы получаем высотку столбца в пикселях. Отрицательную потому что растёт вверх)

    ctx.fillStyle = gistogram.TEXT_COLOR; // задаём цвет текста для имён
    ctx.fillText(name, gistogram.AXIS_X + (gistogram.INDENT_X * j), gistogram.AXIS_Y + gistogram.INDENT_Y); // первый параметр у нас пришедшее из цикла имя, которое и будет выводится (всего 4). Второй параметр это положение имени по оси Х — задаём ему те же параметры, как и столбцу, чтобы стояли ровно. Третий параметр — положение текста по оси У.
    // начальное положение задаётся при помощи начальной положения на оси У к которому мы прибавляем отступы между столбацми

    ctx.fillStyle = gistogram.TEXT_COLOR; // задаём цвет текста для рейтинга
    ctx.fillText(Math.floor(time), gistogram.AXIS_X + (gistogram.INDENT_X * j), gistogram.AXIS_Y - (time * step) - gistogram.INDENT_Y); // первыйм делом округлим наше время до целого числа
    // затем найдём положение на оси Х — задаём ему те же параметры, как и столбцу, чтобы стояли ровно
    // затем находим положение на осикУ: начальное положение задаётся при помощи начальной положения на оси У из которого мы вычтем наши выосты стобцов дабы они не наложились друг на друга, а затем вычтем отступ по оси У чтобы у нас было небольшое расстояние между столбцом и временем
  };

  // перебираем наш массив со временем с помощью цикла
  times.forEach(function (time, j) { // форич принимаем на вход два аргумента — первый это наш какой-либо элемент (время) и второе — его идекс
    getStatsBar(time, names[j], j); // в самом теле фицла мы вызываем функцию отрисовки наших столбцов и передаём туда параметры времени, определённого имени игрока и индекс в массиве
  });
};
